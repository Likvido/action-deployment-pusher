name: 'Deployment pusher'
description: 'Updates the deployment file in another repository, using GitHub App authentication'
inputs:
  repo-url:
    description: 'The GitHub repository URL to update'
    required: true
  environment:
    description: 'The deployment environment (e.g., staging or production)'
    required: true
  namespace:
    description: 'The Kubernetes namespace for the app'
    required: true
  app-name:
    description: 'The name of the application'
    required: true
  new-image-name:
    description: 'The new image name and tag to update in the deployment'
    required: true
  github-app-id:
    description: 'The GitHub App ID'
    required: true
  github-app-private-key:
    description: 'The GitHub App private key. Ensure to handle with care and use secrets'
    required: true
  installation-id:
    description: 'The Installation ID for the GitHub App on the target repository'
    required: true

runs:
  using: 'composite'
  steps:
    - name: Update Deployment File
      shell: bash
      run: |
        #!/bin/bash
        set -e

        # Function to pull latest changes, rebase, and push, with retry logic and random delay
        push_with_retries() {
          local max_attempts=${1:-5}
          local attempt=1
          while true; do
            echo "Attempt $attempt of $max_attempts"
            # Fetch the latest changes from the remote and rebase
            git fetch origin main && git rebase origin/main
            if git push; then
              echo "Push successful."
              break
            else
              if [[ $attempt -lt $max_attempts ]]; then
                # Generate a random delay between 1 and 10 seconds
                local delay=$((1 + $RANDOM % 10))
                echo "Push failed, retrying in $delay seconds..."
                sleep $delay
                ((attempt++))
              else
                echo "Push failed after $max_attempts attempts, giving up."
                return 1
              fi
            fi
          done
        }

        # Function to generate JWT
        generate_jwt() {
            local app_id=$1
            local now=$(date +%s)
            local iat=$((${now} - 60))
            local exp=$((${now} + 600))
            local header='{"typ":"JWT","alg":"RS256"}'
            local payload="{\"iat\":${iat},\"exp\":${exp},\"iss\":\"${app_id}\"}"

            local signed_header=$(echo -n "${header}" | openssl base64 -e -A | tr '+/' '-_' | tr -d '=')
            local signed_payload=$(echo -n "${payload}" | openssl base64 -e -A | tr '+/' '-_' | tr -d '=')
            local signature=$(echo -n "${signed_header}.${signed_payload}" | openssl dgst -sha256 -sign <(echo "${GITHUB_APP_PRIVATE_KEY}") | openssl base64 -e -A | tr '+/' '-_' | tr -d '=')

            echo "${signed_header}.${signed_payload}.${signature}"
        }

        # Convert GitHub App private key from base64 to PEM format
        GITHUB_APP_PRIVATE_KEY=$(echo "${{ inputs['github-app-private-key'] }}" | base64 --decode)

        # Generate JWT
        JWT=$(generate_jwt "${{ inputs['github-app-id'] }}")

        # Fetch installation access token
        INSTALLATION_TOKEN=$(curl -X POST -H "Authorization: Bearer ${JWT}" -H "Accept: application/vnd.github+json" "https://api.github.com/app/installations/${{ inputs['installation-id'] }}/access_tokens" | jq -r '.token')

        # Setup git to use the installation token
        git config --global user.email "sp+deployment-pusher@likvido.com"
        git config --global user.name "Likvido Deployment Pusher"

        # Clone the repo
        REPO_URL="${{ inputs['repo-url'] }}"
        REPO_NAME=$(basename "${{ inputs['repo-url'] }}" .git)
        git clone https://x-access-token:${INSTALLATION_TOKEN}@${REPO_URL#https://} "${REPO_NAME}"
        cd "${REPO_NAME}"

        # Define the directory path
        DEPLOYMENT_DIR_PATH="${{ inputs.environment }}/apps/${{ inputs.namespace }}/${{ inputs['app-name'] }}"
        echo "The deployment path is: $DEPLOYMENT_DIR_PATH"

        # Ensure the directory exists
        mkdir -p "$DEPLOYMENT_DIR_PATH"

        # Define the file path in the target repo for the deployment and cronjob
        DEPLOYMENT_FILE_PATH="$DEPLOYMENT_DIR_PATH/deployment.yaml"
        PLACEHOLDER_FILE_PATH="$DEPLOYMENT_DIR_PATH/add-deployment-here.txt"
        CRONJOB_FILE_PATH="$DEPLOYMENT_DIR_PATH/fake-cronjob.yaml"

        if [[ -f "$DEPLOYMENT_FILE_PATH" ]]; then
          # Use yq document_index to get the index of each document and determine the count
          last_index=$(yq document_index "$DEPLOYMENT_FILE_PATH" | tail -n1)
          # Add 1 to convert the last index into the count of documents
          doc_count=$((last_index + 1))
          echo "The file contains $doc_count documents"

          # Loop through each document and update the image if the kind matches
          for ((doc_index=0; doc_index<doc_count; doc_index++)); do
              kind=$(yq eval "select(document_index == $doc_index) | .kind" "$DEPLOYMENT_FILE_PATH")
              echo "Document $(doc_index + 1) is a $kind"
              # Depending on the kind, update the image field
              if [[ "$kind" == "CronJob" ]]; then
                echo "Updating image tag for cron job to: ${{ inputs['new-image-name'] }}"
                yq eval "(select(document_index == $doc_index) | .spec.jobTemplate.spec.template.spec.containers[0].image) = \"${{ inputs['new-image-name'] }}\"" "$DEPLOYMENT_FILE_PATH" > "$DEPLOYMENT_FILE_PATH"
              elif [[ "$kind" == "Deployment" ]] || [[ "$kind" == "Job" ]]; then
                echo "Updating image tag for job or deployment to: ${{ inputs['new-image-name'] }}"
                yq eval "(select(document_index == $doc_index) | .spec.template.spec.containers[0].image) = \"${{ inputs['new-image-name'] }}\"" "$DEPLOYMENT_FILE_PATH" > "$DEPLOYMENT_FILE_PATH"
              fi
          done

          git add "$DEPLOYMENT_FILE_PATH"
        else
          # Update or create add-deployment-here.txt with the new image name
          echo "Adding placeholder file at: $PLACEHOLDER_FILE_PATH"
          echo "${{ inputs['new-image-name'] }}" > "$PLACEHOLDER_FILE_PATH"
          # Add the placeholder file
          git add "$PLACEHOLDER_FILE_PATH"
        fi

        # Check if the fake-cronjob.yaml exists and update it
        if [[ -f "$CRONJOB_FILE_PATH" ]]; then
          # For simplicity, we update an annotation with the new image name which will trigger ArgoCD sync.
          echo "Updating annotation in fake cron job at: $CRONJOB_FILE_PATH"
          yq e -i '.metadata.annotations."app.likvido.com/last-updated-image" = "${{ inputs['new-image-name'] }}"' "$CRONJOB_FILE_PATH"
          git add "$CRONJOB_FILE_PATH"
        fi

        # Commit and push the changes
        git commit -m "Update ${{ inputs['app-name'] }} in the ${{ inputs.environment }} environment to ${{ inputs['new-image-name'] }}"
        push_with_retries 20

        echo "Deployment file updated successfully"

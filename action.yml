name: 'Deployment pusher'
description: 'Updates the deployment file in another repository, using GitHub App authentication'
inputs:
  repo-url:
    description: 'The GitHub repository URL to update'
    required: true
  environment:
    description: 'The deployment environment (e.g., staging or production)'
    required: true
  namespace:
    description: 'The Kubernetes namespace for the app'
    required: true
  app-name:
    description: 'The name of the application'
    required: true
  new-image-name:
    description: 'The new image name and tag to update in the deployment'
    required: true
  github-app-id:
    description: 'The GitHub App ID'
    required: true
  github-app-private-key:
    description: 'The GitHub App private key. Ensure to handle with care and use secrets'
    required: true
  installation-id:
    description: 'The Installation ID for the GitHub App on the target repository'
    required: true
  deployment-file:
    description: 'If you want to control which deployment file to update, you can point to the file here. This should be the path to the deployment file in the GitOps repo'
    required: false

runs:
  using: 'composite'
  steps:
    - name: Update Deployment File
      shell: bash
      run: |
        #!/bin/bash
        set -e

        # Function to generate JWT
        generate_jwt() {
            local app_id=$1
            local now=$(date +%s)
            local iat=$((${now} - 60))
            local exp=$((${now} + 600))
            local header='{"typ":"JWT","alg":"RS256"}'
            local payload="{\"iat\":${iat},\"exp\":${exp},\"iss\":\"${app_id}\"}"

            local signed_header=$(echo -n "${header}" | openssl base64 -e -A | tr '+/' '-_' | tr -d '=')
            local signed_payload=$(echo -n "${payload}" | openssl base64 -e -A | tr '+/' '-_' | tr -d '=')
            local signature=$(echo -n "${signed_header}.${signed_payload}" | openssl dgst -sha256 -sign <(echo "${GITHUB_APP_PRIVATE_KEY}") | openssl base64 -e -A | tr '+/' '-_' | tr -d '=')

            echo "${signed_header}.${signed_payload}.${signature}"
        }

        # Function to fetch installation access token
        fetch_installation_token() {
            local jwt=$1
            local installation_id=$2
            local token_response=$(curl -X POST -H "Authorization: Bearer ${jwt}" -H "Accept: application/vnd.github+json" "https://api.github.com/app/installations/${installation_id}/access_tokens")

            echo "${token_response}" | jq -r '.token'
        }

        # Function to check if file exists via API
        file_exists_via_api() {
            local file_path=$1
            local token=$2
            
            response=$(curl -s -o /dev/null -w "%{http_code}" \
                -H "Authorization: token ${token}" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${file_path}?ref=main")
            
            [[ "$response" == "200" ]]
        }

        # Function to update or create file via API with retry logic
        update_or_create_file_via_api() {
            local file_path=$1
            local new_content=$2
            local token=$3
            local max_attempts=20
            local attempt=1
            
            while true; do
                echo "Attempt $attempt of $max_attempts"
                
                # Get current file SHA if it exists
                file_response=$(curl -s -H "Authorization: token ${token}" \
                    -H "Accept: application/vnd.github.v3+json" \
                    "https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${file_path}?ref=main")
                
                file_sha=$(echo "$file_response" | jq -r '.sha // empty')
                
                # Prepare the content
                encoded_content=$(echo -n "$new_content" | base64 -w 0)
                
                # Build the request
                if [[ -z "$file_sha" || "$file_sha" == "null" ]]; then
                    # Creating new file
                    request_body=$(jq -n \
                        --arg msg "Update ${{ inputs.app-name }} in the ${{ inputs.environment }} environment to ${{ inputs.new-image-name }}" \
                        --arg content "$encoded_content" \
                        --arg branch "main" \
                        '{
                            message: $msg,
                            content: $content,
                            branch: $branch,
                            committer: {
                                name: "Likvido Deployment Pusher",
                                email: "sp+deployment-pusher@likvido.com"
                            }
                        }')
                else
                    # Updating existing file
                    request_body=$(jq -n \
                        --arg msg "Update ${{ inputs.app-name }} in the ${{ inputs.environment }} environment to ${{ inputs.new-image-name }}" \
                        --arg content "$encoded_content" \
                        --arg sha "$file_sha" \
                        --arg branch "main" \
                        '{
                            message: $msg,
                            content: $content,
                            sha: $sha,
                            branch: $branch,
                            committer: {
                                name: "Likvido Deployment Pusher",
                                email: "sp+deployment-pusher@likvido.com"
                            }
                        }')
                fi
                
                # Make the API call
                response=$(curl -s -X PUT \
                    -H "Authorization: token ${token}" \
                    -H "Accept: application/vnd.github.v3+json" \
                    "https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${file_path}" \
                    -d "$request_body")
                
                # Check if successful
                if echo "$response" | jq -e '.commit' > /dev/null 2>&1; then
                    echo "Push successful."
                    return 0
                fi
                
                # If we've exhausted retries
                if [[ $attempt -ge $max_attempts ]]; then
                    echo "Push failed after $max_attempts attempts, giving up."
                    return 1
                fi
                
                # Retry with delay
                delay=$((1 + RANDOM % 10))
                echo "Push failed, retrying in $delay seconds..."
                sleep $delay
                ((attempt++))
            done
        }

        # Convert GitHub App private key from base64 to PEM format
        GITHUB_APP_PRIVATE_KEY=$(echo "${{ inputs['github-app-private-key'] }}" | base64 --decode)

        # Extract repo owner and name from URL
        REPO_URL="${{ inputs.repo-url }}"
        REPO_PATH=${REPO_URL#https://github.com/}
        REPO_PATH=${REPO_PATH%.git}
        REPO_OWNER=$(echo "$REPO_PATH" | cut -d'/' -f1)
        REPO_NAME=$(echo "$REPO_PATH" | cut -d'/' -f2)

        echo "Repository: $REPO_OWNER/$REPO_NAME"

        # Generate JWT and get installation token
        JWT=$(generate_jwt "${{ inputs.github-app-id }}")
        INSTALLATION_TOKEN=$(fetch_installation_token "$JWT" "${{ inputs.installation-id }}")

        # Check if the INSTALLATION_TOKEN is empty
        if [[ -z "$INSTALLATION_TOKEN" || "$INSTALLATION_TOKEN" == "null" ]]; then
            echo "Failed to obtain a valid installation token."
            exit 1
        fi

        # Determine deployment file path
        if [[ -n "${{ inputs.deployment-file }}" ]]; then
            # Use the provided deployment file path
            DEPLOYMENT_FILE_PATH="${{ inputs.deployment-file }}"
            echo "Using provided deployment file path: $DEPLOYMENT_FILE_PATH"

            # Check if the specified deployment file exists
            if ! file_exists_via_api "$DEPLOYMENT_FILE_PATH" "$INSTALLATION_TOKEN"; then
                echo "Error: The specified deployment file does not exist in the repository."
                exit 1
            fi
        else
            # Define the directory path
            DEPLOYMENT_DIR_PATH="${{ inputs.environment }}/apps/${{ inputs.namespace }}/${{ inputs.app-name }}"
            echo "The deployment path is: $DEPLOYMENT_DIR_PATH"

            # Define the file paths
            DEPLOYMENT_FILE_PATH="$DEPLOYMENT_DIR_PATH/deployment.yaml"
            PLACEHOLDER_FILE_PATH="$DEPLOYMENT_DIR_PATH/add-deployment-here.txt"
            CRONJOB_FILE_PATH="$DEPLOYMENT_DIR_PATH/fake-cronjob.yaml"
        fi

        if file_exists_via_api "$DEPLOYMENT_FILE_PATH" "$INSTALLATION_TOKEN"; then
            # Get the current deployment file content
            echo "Fetching current deployment file content..."
            file_response=$(curl -s -H "Authorization: token ${INSTALLATION_TOKEN}" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${DEPLOYMENT_FILE_PATH}?ref=main")
            
            current_content=$(echo "$file_response" | jq -r '.content' | base64 -d)
            
            # Count documents in the YAML file
            last_index=$(echo "$current_content" | yq document_index | tail -n1)
            doc_count=$((last_index + 1))
            echo "The file contains $doc_count documents"

            # Process each document
            updated_content=""
            for ((doc_index=0; doc_index<doc_count; doc_index++)); do
                # Extract document
                if [[ $doc_index -eq 0 ]]; then
                    doc=$(echo "$current_content" | yq eval "select(document_index == $doc_index)")
                else
                    doc=$(echo "$current_content" | yq eval "select(document_index == $doc_index)")
                fi
                
                # Get the kind
                kind=$(echo "$doc" | yq eval ".kind")
                echo "Document $((doc_index + 1)) is a $kind"

                # Update the image based on kind
                case "$kind" in
                    "CronJob")
                        echo "Updating image tag for cron job to: ${{ inputs.new-image-name }}"
                        doc=$(echo "$doc" | yq eval ".spec.jobTemplate.spec.template.spec.containers[0].image = \"${{ inputs.new-image-name }}\"")
                        ;;
                    "Deployment"|"Job")
                        echo "Updating image tag for $kind to: ${{ inputs.new-image-name }}"
                        doc=$(echo "$doc" | yq eval ".spec.template.spec.containers[0].image = \"${{ inputs.new-image-name }}\"")
                        ;;
                    "ScaledJob")
                        echo "Updating image tag for ScaledJob to: ${{ inputs.new-image-name }}"
                        doc=$(echo "$doc" | yq eval ".spec.jobTargetRef.template.spec.containers[0].image = \"${{ inputs.new-image-name }}\"")
                        ;;
                esac

                # Append to updated content with document separator
                if [[ -z "$updated_content" ]]; then
                    updated_content="$doc"
                else
                    updated_content="${updated_content}"$'\n---\n'"$doc"
                fi
            done

            # Update the deployment file
            if ! update_or_create_file_via_api "$DEPLOYMENT_FILE_PATH" "$updated_content" "$INSTALLATION_TOKEN"; then
                echo "Error: Failed to update deployment file"
                exit 1
            fi
        else
            # Update or create add-deployment-here.txt with the new image name
            echo "Adding placeholder file at: $PLACEHOLDER_FILE_PATH"
            placeholder_content="${{ inputs.new-image-name }}"
            
            if ! update_or_create_file_via_api "$PLACEHOLDER_FILE_PATH" "$placeholder_content" "$INSTALLATION_TOKEN"; then
                echo "Error: Failed to create placeholder file"
                exit 1
            fi
        fi

        # Check if the CRONJOB_FILE_PATH variable has been set
        if [[ -n "$CRONJOB_FILE_PATH" ]]; then
            # Then check if the fake-cronjob.yaml exists
            if file_exists_via_api "$CRONJOB_FILE_PATH" "$INSTALLATION_TOKEN"; then
                echo "Updating annotation in fake cron job at: $CRONJOB_FILE_PATH"
                
                # Get current cronjob content
                cronjob_response=$(curl -s -H "Authorization: token ${INSTALLATION_TOKEN}" \
                    -H "Accept: application/vnd.github.v3+json" \
                    "https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${CRONJOB_FILE_PATH}?ref=main")
                
                cronjob_content=$(echo "$cronjob_response" | jq -r '.content' | base64 -d)
                
                # Update the annotation
                updated_cronjob=$(echo "$cronjob_content" | yq e '.metadata.annotations."app.likvido.com/last-updated-image" = "${{ inputs.new-image-name }}"' -)
                
                # Update the file (ignore failures as per original)
                update_or_create_file_via_api "$CRONJOB_FILE_PATH" "$updated_cronjob" "$INSTALLATION_TOKEN" || true
            fi
        fi

        echo "Deployment file updated successfully"
